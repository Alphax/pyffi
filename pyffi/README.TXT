PyFFI is an open source Python library for processing block structured
binary files.

The Python File Format Interface aims to make it easy to manipulate
binary files in a Python environment. Starting from a file format
description written in XML, PyFFI creates customizable Python classes
to read and write file blocks as described by the XML. Currently,
PyFFI supports the NetImmerse/Gamebryo NIF and KFM formats,
CryTek's CGF format, the DDS format, and the TGA format. Many tools
for files used by 3D games, such as a stripifier, and a tangent space
calculator, are included in PyFFI as well.

PyFFI's highly modular design make it easy to implement support for both
new formats and also to extend existing functionality.

QSkope is PyFFI's graphical user interface, and enables simple editing
of files in any file format supported by PyFFI. QSkope depends on PyQt4,
which you can download from

http://www.riverbankcomputing.co.uk/software/pyqt/download

Overview
--------

The general philosophy of the library is to supply all information
that comes naturally from files. For very common calculations, extra
functions are available, to make life easier for importers and
exporters. Very specialized functions are implemented as tools
(typically, as scripts or spells) rather than as class methods.

If you are developing a particular file format, then you can specify
an alternate location of your xml file, for instance cgf.xml,
by setting the CGFXMLPATH environment variable to the directory where
cgf.xml can be found. If CGFXMLPATH is set, the library will first
look there. The same applies to all other formats.

The code is organized as follows.

* Python File Format Interface - representing a file format specified by an XML
  file in Python

  - PyFFI/__init__.py

    Contains the main metaclass which generates classes for each type
    defined in the XML.

  - PyFFI/XmlHandler.py

    The XML handler, contains the core code that transforms the XML
    file into classes. The parser code is based on NifSkope's XML
    parser (see http://niftools.sourceforge.net).

  - PyFFI/ObjectModels/

    All base classes for various classes generated by the
    XmlFileFormat metaclass, i.e. basic and struct. Also contains
    the implementation of array's and the expression parser.

* CGF Format Library - instantiates classes, and customize them

  - PyFFI/Formats/CGF/__init__.py: instantiates classes for the CGF format

  - PyFFI/Formats/CGF/*.py: customization of particular blocks

* NIF, KFM, TGA, and DDS Format Library - similar to CGF

* Utilities

  - PyFFI/Utils/__init__.py: collection of random small utilities

    + hexDump: dump file chunk in hexadecimal format

    + walk: a variant of os.walk()

    + TriStrip: stripifier utilities (uses a Python port of NvTriStrip)

    + MathUtils: common vector and matrix operations

    + QuickHull: a simple implementation of the 2d and 3d quick hull
      algorithms

    + Inertia: a library for calculating mass, center of gravity, and inertia
      tensor of common shapes

  - PyFFI/Spells/NIF and PyFFI/Spells/CGF: format specific helper modules

  - PyFFI/QSkope: modules used by QSkope (PyFFI's GUI application)

  - scripts/NIF, scripts/CGF, ...: format specific scripts

    + niftoaster, cgftoaster, ...: for hacking files with spells

    + ffvt3rskinpartition: skin partition calculator for Freedom Force vs. The
      3rd Reich

    + nifmakehsl: create hex workshop structure libraries for all nif formats

    + nifoptimize: remove redundant vertices and restripify nif files

* Documentation - generated by epydoc

  - docs/...

* Test files

  - tests/...

* examples

  - examples/simple

    Simple example on how to implement a new format.

  - examples/metaclasses/howto_generate_class_from_xml.py

    Proof of concept of how classes can be generated from an xml
    description. I keep it there as it could be useful to get a quick
    idea of how the XML is converted to a bunch of classes.

The following code resides in the subversion trunk only
(https://pyffi.svn.sf.net/svnroot/pyffi/trunk) and is not distributed
with the library.

* various scripts

  - rundoctest.py: runs all tests in the documentation

  - makezip.sh: script which creates the distribution packages

  - pylintrc: pylint configuration file

Migrating from PyFFI 0.x.x to PyFFI 1.x.x
-----------------------------------------

There are a few API and organizational changes between the 0.x.x
releases and 1.x.x releases. Most projects using PyFFI should not be
affected too much by this, and the migration should be fairly
straightforward. But if you have really serious problems migrating
from PyFFI 0.x.x to PyFFI 1.x.x even with the documentation below,
post your problem on the sourceforge tracker:

http://sourceforge.net/tracker/?group_id=199269

Following is a detailed list of important changes and the minimal changes
required to your code.

* Instead of PyFFI.XXX you should now use PyFFI.Formats.XXX; from a
  linux prompt, type for instance (assuming you have find and perl
  installed)

    find . -not -wholename "*svn*" -exec perl -pi -w -e 's/PyFFI\.NIF/PyFFI.Formats.NIF/g' {} \;
    find . -not -wholename "*svn*" -exec perl -pi -w -e 's/PyFFI\.KFM/PyFFI.Formats.KFM/g' {} \;
    find . -not -wholename "*svn*" -exec perl -pi -w -e 's/PyFFI\.CGF/PyFFI.Formats.CGF/g' {} \;
    find . -not -wholename "*svn*" -exec perl -pi -w -e 's/PyFFI\.DDS/PyFFI.Formats.DDS/g' {} \;
    find . -not -wholename "*svn*" -exec perl -pi -w -e 's/PyFFI\.TGA/PyFFI.Formats.TGA/g' {} \;

  and manually check the changes.

* the XxxFormat.getVersion methods now always returns two integers,
  namely the version, and the user version; to find all instances,
  type

    find . -not -wholename "*svn*" -exec grep -ln "getVersion("

  to find which of your files might be affected; check that they are
  indeed of the form

    version, user_version = XxxFormat.getVersion(...)

  This does not affect the nif format as this method already returned
  both version and user_version. All other formats are affected.

  The CgfFormat.getVersion function also no longer returns the file
  type. This is delegated to the read function now. You can use the
  CgfFormat.getFileType function to get the file type without having
  to parse the complete file.

* Similarly, the XxxFormat read and write functions have been unified, in the
  following way:

  - XxxFormat.read(stream, version, user_version, ...), returns a tuple
    say readresult

  - XxxFormat.write(stream, version, user_version, *readresult, ...)

  Use for instance

    find . -not -wholename "*svn*" -exec grep -ln "Format\.read("
    find . -not -wholename "*svn*" -exec grep -ln "Format\.write("

  to find out which files might be potentially affected.

  In particular, the cgf format no longer takes the game argument, but
  uses user_version instead (i.e. CgfFormat.UVER_CRYSIS and
  CgfFormat.UVER_FARCRY, also check the CgfFormat.getGame and
  CgfFormat.getGameVersion methods).

* The nameAttribute, walk, and walkFile methods are now commonly
  implemented for all format classes, so please check them if you used
  them. In particular, the API for the walk methods has slightly
  changed. Again you can use "find" on linux to check which of your
  files might be affected.

* The format tester modules have been removed as well. Their
  functionality has been merged into PyFFI.Spells.NIF,
  PyFFI.Spells.KFM, and so on, so use these new modules if
  possible. Usually, this should be enough:

    find . -not -wholename "*svn*" -exec perl -pi -w -e 's/NifTester/PyFFI.Spells.NIF/g' {} \;

  and similarly for other formats.

* The different format toaster functions have been unified into the
  new PyFFI.Spells module. The code for the niftoaster, cgftoaster,
  etc. scripts is now much simpler, so if you implement your own toasters,
  you may wish to make use of the new PyFFI.Spells.toaster(...) function to
  take advantage of this as well.

* NifVis is no longer distributed; the code is still on the repository
  and eventually it will be merged again, not as a toaster, but as a
  part of qskope. This may take a while.

* If you used qskopelib before, it now resides in PyFFI.QSkope, so
  update your import statements to reflect this.
